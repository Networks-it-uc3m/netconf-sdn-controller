# Important Links
* [Sysrepo](https://github.com/sysrepo/sysrepo)
* [Netopeer2](https://github.com/CESNET/netopeer2)
* [YANG Data Model for IPsec Flow Protection Based on Software-Defined Networking RFC9061](https://datatracker.ietf.org/doc/rfc9061/)
* [PF_KEY Key Management API, Version 2 RFC2367](https://datatracker.ietf.org/doc/html/rfc2367)

# Modes of operation
![](https://hackmd.io/_uploads/Hk6Mhj9xa.png)

## Host-To-Host
This mode of operation, is for only between two hosts, with direct visibility.

![](https://hackmd.io/_uploads/SJlfhi9la.png)

## Gateway-To-Gateway
This mode of operation, is for enabling a protected communication between two subnetworks.

![](https://hackmd.io/_uploads/ByTxhscx6.png)

# Project structure

The project directory is divided as follows:

### src

This directory has all the code that is needed to run the cfgipsec application:

* `log.h/log.c`: Module used for logging.
* `utils.h/utils.c`: Module that provides some general functions used across the entire code.
* `messages.h/messages.c`: Defined the messages that can be shared between the TA and the RA, and the code for marshalling and unmarshalling, following a JSON format.
* `pfkeyv2_entry.h/pfkeyv2_entry.c`: Define the functions to interact with the XFRM framework trhough the PF_KEY Mgmt API
* `pfkeyv2_utils.h/pfkeyv2_entry.c`: Provides some function to log the messages that are been sent and received to the PFKey Mgmt API.
* `sad_entry.h/sad_entry.c`: Specifies the internal structure to manage the SAD entries. It also defines some of the methods to generate marshall/unmarshall to a JSON structure.

* `spd_entry.h/spd_entry.c`: Specifies the internal structure to manage the SPD entries.It also defines some of the methods to generate marshall/unmarshall to a JSON structure. TODO:
    * Add support for SPD entries.
* `sysrepo_entries.h/sysrepo_entries.c`: Defines the methods to parse the information from and into SYSREPO. And aslo specifies the method to submit a YANG Notification and to delete a SAD entry when it is requested by the kernel.
* `sysrepo_handler.h/sysrepo_handler.c`: Defines the methods and process that will be reading from changes of the SYSREPO datastore (only supported ADD/DELETE). Also, specifies the method that will handle some of the events from the PF_KEY management API which later needs to be handled by SYSREPO for deleting or sending.
* `sysrepo_print.h/sysrepo_print.c`: Defines the methods to print the SPD/SAD values currently stored in the sysrepo datastore, and used to print some specific values.
* `trust_client.h/trust_client.c`: Defines the method to interact with the TA developed using enarx (trough a TCP socket).
* `trust_handler.h/trust_handler.c`: Process that runs in the TA that will handle the incoming requests from the RA. For the moment it only support the interaction with the SAD entries. TODO:
  * Add support for decrypting config values.
  * Add support for SPD entries.
### cmd
In this directory it is defined the "entry points" of the code that is going to run the ccips.
* `i2nsf_ra`: Specifies the code to run the RA side of the application `main.c`, and the imports and compilation options needed `CMAKELists.txt
* `i2nsf_enarx`: Specifies the RUST code that is going to be neede to run in the TEE launched by the ENARX framework. It also specifies a CMAKE that basically is use to export all the libraries needed from the CCIPS so it can be imported to RUST.
    * Inside the directory `i2nsf_enarx/enarx`, we specified in the **`Enarx.toml`** file, the configuration such as the tcp socket and port, and in **`launch.txt`** with the command to launch enarx.  In the **`Cargo.toml`** it is specified some values that are needed by the Cargo compiler to create the enarx application in WASM. 

### yang
In this directory they are stored all the YANG models that are needed by the cfgipsec application, primarly used for the docker installation, but this files need to be installed in a standalone version (without docker).

# Workflows
## Starting point:
When launching the application, the cfgipsec2 tool needs to stablish a session with sysrepo relying in the SYSREPO libraries. It will subscribe to the changes of some specifics XPATH (identifier):
* `/ietf-i2nsf-ikeless:ipsec-ikeless/spd/spd-entry`: Subscribe to the changes in the SPD Sysrepo database. This changes will be handled by `spd_entry_change_cb`.
* `/ietf-i2nsf-ikeless:ipsec-ikeless/sad/sad-entry`: Subscribe to the changes in the SAD Sysrepo database. This changes will be handled by `sad_entry_change_cb`.

Also, it needs to subscribe to the events generated by the kernel through the PF_KEY managament API. This is done by calling the function `sadb_register` which then call the `pf_exec_register`. The lattest, will make some verifications before launchin the thread that handles the messages sent by the kernel `pf_sadb_esp_register_run`. 
## Installing a SPD Entry:
![](http://cdn-0.plantuml.com/plantuml/png/XPFDRjim48JlUeg5Jmtwym0-577beZK214QKGme445RaAYPABLcIIk8-VIdIaEb2QOysPxuPxbBNFg0Buw2hZGZ6GGteOLNNktq3jU7WZDRaLfMDAYMKHGxG94rpz8wiMLMTUOLak11v54dchMmfSewjE20_KIkwrTz2dPGePRFVPl6bn7bC2aVubiJZ36cdI3QILfN4W1rwWdoeM8NYjFJRFaVOleq8QxGICO5OGhpUXV8cwNwIOzAh2iTWU1mwSbKD7pz3iuOx-ZMI3w3O1zGQJ0-nDAJIdwfcKdaKQxWrGVL7mCwC0H3oUA8Bme7WOR-v_rv5tIpVIU9a20USz4mlPoue3x4toQ8G-63i8gBmxRQPTq0F7H5dIk7IQsY8PHcLAOeSlElGAu5Q7rDfne6ku7sgzcen7CesZlmuq4JMP_IELL2erMy2PA31XYFCBoQj2PPkb0ZEuppi71zZepdN_00MlN_agQkZN0UGvMB8LHLXb-kxf45t1ElCivAAdr9OoQsQkS-kFndeLVdWeJVk1PrC5iNnru116JxbPSyUdITm94WzaonbZpmrxfNMYxKJPPxb7ONHCGZZ8Yg0ZTHOzfyhqCK0pJHTDq-nY5dOGF97TvCio_8oCHjiZsNW_8N4uJpo1MJ-3l9tLaNd3FX6J0u3GRFPVcaVslWoDzij3EGzFaLG1AEK_xl3YNWJLtPg4Jdjrzlxkn_LpIdhV2OCz-gqb8NxHUqyq6NByWJJuXOTXU9DWKWlTlauFybw3NNn9vW-FyHiIBfhOZaE-Wy0)
* Suppose that the Controller has sent two SAD entries and two SPD entries. One for each direction of the tunnel.

1. The CCIPS controller request to install a SPD entry following the NETCONF message with the `<edit-config>` operation.
2. This is received by SYSREPO through the NETOPEER2 process and then it notifies to all the subscribed process that there has been a modification in the datastore.
3. This is received by `spd_entry_change_cb` since it has been previosuly suscribed. When received this notification (a change in the specific XPATH), it needs to first identify that a new SAD entry has been added into the datastore. Uppon doing this it extract the identification of this new entry so it can be sent this information along the entire **XPATH+ID** to the `addSPD_entry`.
4. When the method `addSPD_entry` is called, it first request to SYSREPO using the entire XPATH all the information by calling the method `readSPD_entry`. The lattest whill request the information of the specific XPATH and will parse the information to fill the information of a`spd_entry_node`. 
5. This information is then passed to the `add_spd_node` which will store the sad_entry_node in local database which is pointed as the `init_spd_node`. 
6. Then it is requested to the method `pf_addpolicy` to proceed with the installation of the `sad_entry_node` into the kernel.
7. This process starts by generating a *SADB_X_SPADD* message using the values of the `spd_entry_node`, an d then it will be directly passed to the kernel through the PF_KEY managament API.
8. If The entry is correctly installed, the confirmation will be forwarded back to the controller.
## Installing a SAD Entry
![](https://cdn-0.plantuml.com/plantuml/png/XPFDRjim48JlV8g5JWtwym0-577beZK2146KGmi445RYAYPABLMIIg8-VIdIaAM2ROysPxuPxPBNpgFrOw_5llN6GWdee2ZBurq5fM5lZTPa2p44bMhLWEoXYffgSfO6KuZ6l48qR4GEsoXpA6iAdAbkJyXFLBTDyQTGHoLAMUqFIRoLM8THOGbpaaHP8FKSoKPI8IHwRD0Hf4F5oY-dM__GfOYXgmCYQ0f1B25ysqPs4qK_o3BfGk3e3OzzGrQKyFuZL3kufvyZEG-AdKUjmNGG6aDi_45KiyfXkuDRurKt0JPcz82GPXDSu4y4t-xs3rz5q2toeoIE1d_2MS_qSk62SX1AarmL0kVDa4TSVCT3uftGGKF4YR9owHrKn78TbIYABBnfqAaMjPvYQSQUhk1jhFOwe3-jsrXoOqypML_GHrPUeLQ_2921-i5Fi5oNk2F8V54YM8VBi5DyY0tcLFCT3EZS8yzTBQKwW2op8LSYmBRhszAWcM2mvbb9nKynRCqLrTBds9qDzAgSTz0P-u9MHelYyAj7hmpFUOld3gqZiDIIUYQvbZtotBXJMcThHyeootloesLeZGqe3qEWXhB_N85U3T3CqxLfYjkOp0QYFxYhQCdBrud9C7Iu3bnUI1ZE8syWopj8xqm4vmBuGamMFSrNybEzFnoW9-VmAJ024wNyN_qpx2PiAnMOIVNdsuVxx-Bc77CvQmrtwhoFpAS5xJBBl2K_lBIphEEY-AkWJPSrUvnkOxc3SlKdc2xTmMI8kcjYEVRwDm00)
* Suppose that the Controller has sent two SAD entries and two SPD entries. One for each direction of the tunnel.

1. The CCIPS controller request to install a SAD entry following the NETCONF message with the `<edit-config>` operation.
2. This is received by SYSREPO through the NETOPEER2 process and then it notifies to all the subscribed process that there has been a modification in the datastore.
3. This is received by `sad_entry_change_cb` since it has been previosuly suscribed. When received this notification (a change in the specific XPATH), it needs to first identify that a new SAD entry has been added into the datastore. Uppon doing this it extract the identification of this new entry so it can be sent this information along the entire **XPATH+ID** to the `addSAD_entry`.
4. When the method `addSAD_entry` is called, it first request to SYSREPO using the entire XPATH all the information by calling the method `readSAD_entry`. The lattest whill request the information of the specific XPATH and will parse the information to fill the information of a`sad_entry_node`. 
5. This information is then passed to the `add_sad_node` which will store the sad_entry_node in local database which is pointed as the `init_sad_node`. 
6. Then it is requested to the method `pf_addsad` to proceed with the installation of the `sad_entry_node` into the kernel.
7. This process starts by generating a [SADB_ADD](https://datatracker.ietf.org/doc/html/rfc2367#section-3.1.3) Message using the values of the `sad_entry_node`, and then it will be directly passed to the kernel through the PF_KEY managament API.
8. If The entry is correctly installed, the confirmation will be forwarded back to the controller.
## Removing SPD Entry:
![](https://cdn-0.plantuml.com/plantuml/png/VLJDRjiy4BphAHOwsVZmzG4Cj4Wg1wsHeZMY77em8AoabKs4MghagedVlk9F52TnVERCxCp-yCe9MXbxdLqtOYmKW0xoejXiIoWCYpLQayspOKAfHWt80cN0b4TdQJ1vLfid28HN88TDWBcXhMZIELRD0NbFLLFdRu4w82trvY-Lr-k8VuqQEWoWeQjQqeFHgdc3i0wJ3BOVY3YCbIQ5oljYqrAUjIXOeoE8ZugLdBmIjp0bVALp6u0FP9bqdk4eXiU-9fiLyFyNA5TmHtz6SW8jQH82qq6vNKDmjEC5Doipa4LHXZ_d4PClFsMbPpjiLl3JYEgEWBKP1H1Yvq0no87Wz_Rw_disuMRufYNsXF0ino5KjCd3ehohVcshzSsFc_kRzVB4BZWnmtcXsIvirfCg2YW7UwDu3sAWffIiFM7h5PJ4xGbLHJL5TWfTerCDQXrDClQqXF-0wH6U1fJ3gIrBRkp9IsklhL_wgSqauMrRQcEHSt7qYwFYGCq3ADyD6Iq_itmQDW8yQWsBZG0zAITkUS75qE6RkIh3OBeGPywSJR0P_OtOJvbWMiUlQG3GatEu9tXKSWXSnPsnVLY67IUzb72-dR2BxwAcMhUnyREo68YhcTqcA-2T-_pWngQPOB1GtPmvoVYWxt2cImsBnzb2PqsVv2yqow6N2fJ8ZxmulkTxEpEwGFwOkkDdBY1xBqIXNVq4jyUpVavtmN2dR3yFxzBgd46dJI_VFmKpyI1sh2GQJjyZh54mZ3EUTt56-Ogu7Nlz3m00)
* A SPD entry is already installed in the SYSREPO database and in the kernel.
1. The generates an XML using the `<edit-config>` option, specifying the SPD entry to be delete (identified by their name or ID) and adding the option `nc:operation="delete"`, requesting the deletion of the entry.
2. This is received by SYSREPO through the NETOPEER2 process and then it notifies to all the subscribed process that there has been a modification in the datastore.
3. This is received by `spd_entry_change_cb` since it has been previosuly suscribed. When received this notification (a change in the specific XPATH), it needs to first identify that it is requested to delete a SPD entry. Uppon doing this it extract the identification of this entry so it can be sent this information along the entire **XPATH+ID** to the `removeSPD_entry`.
4. This method it will check at first if the SPD entry was stored in the local database `init_spd_node`.
5. Then it is requested to the method pf_delPolicy to proceed with the deletiong of the spd_entry_node from the kernel.
6. The lattests will generate a request through a *SADB_X_SPDDELETE* message which will delete the installed SPD if it exists.
7. When the SPD entry is removed from the kernel, it will proceed then to remove the entry from the local database `init_spd_node` using the method `del_spd_node`.
8. Finally, it will confirm the deletion of the SPD entry notifiying the CCIPS controller.
## Removing SAD Entry
![](https://cdn-0.plantuml.com/plantuml/png/VLJBRjim4BphAnOwsIZQ3p3G8gaSj4QADeXow265i9PMDX5ggPAh9lxxyi7uaJWvxynmPfRaXHEqCWswk6p5MAW07PHLjRgfeJ8ircXDjYn6ZrAj6f45weYfTyxIQCfYRPuW4av03ji8SzWrv7LsJRj5tb3JhikNG1sHbWRpZ-hBPSAVeiOU8sZicuwq5pqTMuTP0xit51ocOpoz2QROT5GM7GgkqH6aeM8bHrFY3doy4vth27mWowJB0YSnF0rhiaK57xz0lO1R-ZkH4_07aH2O7hmZY8x-y8pRXHd9eYZ3dyk4AUUVYjgpGnSB-6b4zJl0jPa4459je1XaI_3xvlBkU-5nU_Yg8mw4E9RT64-qsSEilcr-tJJBgnzNTrVB-P5TS6B6iq87kx1QUbKKK0usHl46nC2QShBkYAqNK8Uo3bILr1HPcFc2LOjQ9u-C0ytX0p0zmjE8iZrsPSbD0mLb7QJreKvjl4HmRQbBPvnBem-6gYsr3w126J9PVcQ5C6m4UD8QPYi1Ub9EtFmT5sEFBzQg38FfGvn3vCB3zkXln679SVmrzmy3EOSRWaSbsyXLt1ixO92xvwoN4nxUJRYAhwBciwvJxtjbCP1kPd6ThK1m7lA3czhMms2c-dtc0CY5lSAPFXUM7cO7lJL3bd-dB8T1Ab8oF_3o-fwVsvdLHVBRr7j-vW9oy48KwneytExE-Zc-2uPxPOVzyjwxEcVG-QBNhqV1J7uFzwma6SvV8onHCAuplUxgZF85SJSD-Zy0)

* A SPD entry is already installed in the SYSREPO database and in the kernel.
1. The generates an XML using the `<edit-config>` option, specifying the SAD entry to be delete (identified by their name or ID) and adding the option `nc:operation="delete"`, requesting the deletion of the entry.
2. This is received by SYSREPO through the NETOPEER2 process and then it notifies to all the subscribed process that there has been a modification in the datastore.
3. This is received by `sad_entry_change_cb` since it has been previosuly suscribed. When received this notification (a change in the specific XPATH), it needs to first identify that it is requested to delete a SAD entry. Uppon doing this it extract the identification of this entry so it can be sent this information along the entire **XPATH+ID** to the `removeSAD_entry`.
4. This method it will check at first if the SAD entry was stored in the local database `init_sad_node`.
5. Then it is requested to the method `pf_delsad` to proceed with the deletiong of the sad_entry_node from the kernel.
6. The lattests will generate a request through a [SADB_DELETE](https://datatracker.ietf.org/doc/html/rfc2367#section-3.1.4) message which will delete the installed SAD if it exists.
7. When the SAD entry is removed from the kernel, it will proceed then to remove the entry from the local database `init_sad_node` using the method `del_sad_node`.
8. Finally, it will confirm the deletion of the SAD entry notifiying the CCIPS controller.
## Rekey:
### Soft-Lifetime:
![](https://cdn-0.plantuml.com/plantuml/png/VLBDRfj04Bxp52FVezvpgE8IjxKYkLR88OTAQ647l2hiRcPcLVljEooE2sgL8vhlVtbWCIHf78fjAu6W1CEmASlziO8oUA4m34YR8YhAjIuQBr1bJ7LXmXWsHHFEa0ahq5C6_KBoEApfiQDyYrtDnZOrSgm9UyU2L5Foi8QpyHdEwAqIQZn7HrZx8AvphH4N_AQmHanZ6678MEUTJEAAihWfb0cQiZ19WazZWrGymTtdASazLDErUjm-VgbthyVzymv6P3Oz5dg-eVOMlHfUG2uH8NGVWrm7Ji0nc9-UGoTtW-jGt8YVJeRixGkM9VwlL1ttq54OGKuuUsB_ZjHbxk4PtnAoG8yUAGjDwGwxb_B7uUlQGF4tshPzImu9uVgCmAgjeCL6m1BYEydmNwiXj6QOheGMffKrArtorYkFtLd8jBh3N4RjD5ekaXK-edwRso0S5WNKab8hYH2Cjs0qSE-X3KJ8CNZhV0-ln-tBzsK9lQNn9bvTttkv2uYsdrVGS1HIVmAcEaFg_DS98S8_orIJO7a_Hxm0fuPRSWrQoBylClnsSifzhu-3Q-FYGSNJEFm1)
1. This process starts when the one of the *soft-limits* defined when configuring the IPsec tunnel is reached. In this example, it has been reached the lifetime threshold, where the kernel generates a [SADB_EXPIRE](https://datatracker.ietf.org/doc/html/rfc2367#section-3.1.8) message notifying the subscribed parties, that a SAD is going to expire. 
2. This message is handled by `pf_sadb_esp_register_run` which first needs to identify if it is SADB_EXPIRE mesage or not. In the case of an expire message, it will then proceed to identify if it corresponds to a **soft-expire** or a **hard-expire**.
3. Supposing that it has recevied a **soft-expire** message, it needs to extract the SPI from the message.
4. Once identify the associated SPI of the SAD entry that is going to expire, it proceeds to generate a NETCONF notification calling the method `send_sa_expire_notification` and passing the SPI and the type of expire notification.
5. This method will first acquire a new connection to sysrepo, so it can interact with it. After this, it will proceed to generate a new [`lyd_node`](https://netopeer.liberouter.org/doc/libyang/master/html/tree__data_8h.html#structlyd__node) (variable `notif`) calling the SYSREPO method [`lyd_new_path`](https://netopeer.liberouter.org/doc/libyang/master/html/howto_data_manipulation.html) structure assigning the XPATH `/ietf-i2nsf-ikeless:sadb-expire`. Then it will extract from the local SAD database `init_sad_node`, by using the SPI the associated `sad_entry_node`. If it exists, it will proceed to generate the NETCONF notification by configuring the `notif` variable.  
6. After configuring the notification (adding the name/id and type of sof-lifetime-expire value) it will call the `sr_notif_send_tree` method to send to the subscribed to the corresponding XPATH, a NETCONF notification notifying that the SAD entry associated with a name/ID is about to expire (soft-lifetime).

At this point the controller will have received the expire notification with the corresponding identification of the SAD entry to be removed. With this information it must proceed with the following steps:
1. Identify which nodes have the associated SAD entry
2. Generate a new pair of SAD entries with the same SPI but different rule-number or **REQ_ID**. 
3. Install following the same process explained in [here](#Installing-a-SAD-Entry).
4. After installing the new entries, the controller proceeds to remove the previous entries following the process explained in [here](#Removing-SAD-Entry)
### Hard-Lifetime:
This process is the same as the one followed for the soft-lifetime case. However, before sending the NETCONF notification (in this  case telling that is hard-expire notification), it proceeds to delete de SAD entry from the sysrepo datastore by calling `send_delete_SAD_request`. 
Take into account that, after a hard-lifetime notifiaction, the SAD entry is automatically removed from the kernel.  
## TEE:
### With Enarxs:
<!-- #### Compilation details
When Running the ENARX version we must take into account to considerations:
* The part running in the RA, needs to be compiled as the default option but we need to specify the option `ENRAX_RA` to ON like below
```bash=
cmake -D ENARX_RA=ON ..
```
* When compilling the Enarx WASM binary we need first to have compatible [wasi compiler](https://github.com/WebAssembly/wasi-sdk/releases/tag/wasi-sdk-17). In this case, we will need to compile the code under the `build` directory as follows:
```bash=
    cmake -D ENARX_TA=ON ..
    make
    make install
```
Once it has been installed you can check under the lib directory (which is created in the root of the project), that it has been generated some linkables files that will be used later by the RUST compiler.

With this files, we can go now to `repo_directory/` -->
The communication between the RA and TA of the CCIPS application when using Enarx, for the moment relies in a TCP connection (without any type of encryption), where the TA works as a server. It provides and endpoint, where the RA sends the request using a JSON format, with the library [parson](https://github.com/kgabis/parson).

#### Startup
When the cfgipsec starts, there should two different process running:
* The main process of the cfgipsec which will be compiled with the option **ENARX_RA** options which will enable the `add_compile_definitions` *Enarx* and *Trusted*. When starting the application it will try to connect to the Trusted application running inside Enarx through a TCP connection.
* The other process runs inside a container and inside the Enarx Framework. It is a rust programm, that is compiled using some of the cfgipsec exported libraries. It provides a TCP endpoint to interact with his internal API.

#### SAD entries Mgmt:


Installing new entries: 
![](https://cdn-0.plantuml.com/plantuml/png/ZLJ1RkCs4BthAmO-TT5sWRRRImx5kdAQka6zWHMWBM1069EZY5Y9P4agYVhr9QdGb18RkxV4VE_DcpUZ-MWT6ZVqNR5cJXae0Isiod9xLq6ff3EgwyYi2krHWWcDqa4LCTLe3McrAexg6IR2Vht0MMGHQP7NvAN6chKe7wXcnzLhO1UHo7crtapW9SHOZ0X3U0bYyIHIXv9ISLeL71qUqH9CZq8AbryNV7Jsn7Tci8wYphbIkfdSwARsQ0-Qft2_JA7j8zHtpZkgUx8M7rvLRYLRW2GzrKp99gDp5swgd0o-weSaX-0a_R4eSnkPdyb8wbO53ax9eJ-IAKhu_XUehc1F_mva7GXf7NOTg0PyrX03U5zK0MMHNS5EET6CW4SrE42OfkfPu5g2l-_MzxyN7dU2Rpd9I70j1hnlB-k2iE0p93up1DOfVLuYyxQRIQz52qSY-QAIMTqLL2JvlDIa8iZ0DpvDmNoJOpGjiQTty6sqzgpHjNCtXkpGKr3kilJM1o-m4_yHe0JgjHiXBtgO1fphA2eOYpdiM9wU0dco-HrejFOWWrT3anrVWvyjygxmOilnBTNWE88swb5m8HzYiRbkKPtyR9iN0ZqBwomqoZoXuP4YfF-lHoUKJFKYvmwD9J34I3mIdyCECZXkHDUTjHrKSfPxSeEHm9JnKWwqL_Lcv_5zUF_3AJrqDlVgSpKKqzaGCwDsUTnlulV4m6_xbyNONVzLbvzslsrlwZ-h6tWIhZt8FwfFEyzdtYH_PNffwCUYxPDSpC52v4xVx9dfPtZ-84PDe9h4MHRuAJ4awtF3gStGScp-RHt9CY_XBGmXKz16FA8Z-4nZ0iQRuYE9IN9Yez7kRUzBRnzobJxDB-xTadKX0tJsCYbwC6Fqy8YTRng4XEskkjxVrzUx-_q_OLfXc7c1IgN7e9G8OPHnSPKaUzhFkPkVPvzpbzDrQWhrQthnn9XUYkuYF1-GID0DBWgcQ-lz7kHI9DtKwMONddaIk2591Xs5VV-rNcysQOaEqciYvr-mdyHk_JfE1eBI571n-r8clp4b6v5EmDlMF3Pb-KLA3Y-Exn8Z8ou2M01K5vxZPIl3RkGVGJKXpnHvn7qaoOU--ny0)
4.1. When a request to install a new SAD entry. If the CCIPS is compiled using the **ENARX_RA** option, before storing the sad_entry_node (which is already parsed from sysrepo), it is first sent to the TA a `NEW_CONFIG_MSG` message, using the `trust_client` through the method `add_trusted_sad_entry`.
4.2. The TA handles this process through the `handle_message` method of the `trust_handler.c`, which basically obtains the values from the JSON.
4.3. After identifying the type of message, it continues by first identifying the values and the decrypting them by calling the method `handle_new_conf_message` sent by the controller *(The lattest is a TODO since it is not implemented)*, and then it must store the new values of the extracted `sad_entry_node` values in a local-trusted database `trusted_init_sad_node` inside the RA.
4.4. Finally the TA will return the decrypted sad_node_entry through another `INSERT_ENTRY_MSG` message, so it can use the new values to continue with the process of installing the SAD entry to the kernel.

#### Removing SAD entries:

1. After the entry has been deleted from the kernel, the RA request to the TA using the method `del_trusted_sad_entry` of the `trust_client` to delete an specific `sad_entry_node` by specifiying the ID/Name of the entry.
2. This will generate a `DELETE_CONFIG_MSG` which that is sent to the TA.
3. The TA handled the incomming message `handle_message` of the `trust_handler.c` which will detect the type of message.
4. This information is then passed to the `handle_request_remove` that will basically remove the `sad_entry_node` if it exists from the `trusted_init_sad_node` database.
5. Once remove, it will forward back to the RA a `OP_RESULT_MSG` specifiying if the operation was sucessful or not. 

#### SAD entries monitoring
![](https://cdn-0.plantuml.com/plantuml/png/VP91Qnin48Nl-XM3xosqoIc74kCwmT3IrBifzBJ8rgmbM4dRqUow-VULv7XtHKF0u8FUz-QzcRqFB8a7suc3_mkRpUwfWlrQo2DxWXfaW5Mj2QLQYJuApT7qqZ6CmUMt4ScqBqsGgd5UOLW99LaUP43eii0umzDpwT6tfopfs-Q47D88T0fYZaMMUbqmscP4IwSwR2o684zOsceQ2n7Xdm43DvUeCpC7PPdrJ4DWL4qHUSua1_Pki0SaKSE7Bsa5Tx2_c4Er_Whec0m6o8FCKRBnJaHL4dUpDB0dL4iYRTkCaZ5v2kSvPiAMHQrDWFZhaLfFDaBn3r0UDOYKB-4lEUNLr3XWZL0qc8hc9ibzKGLkFdwwPeptc5CQbqRc3j2Ijzat3opfpucUrl683YaLOTj36R74RgwOjdTGfM2bEZNPRty-Rwkw-RNTxnv-Dz-hnuL7QjmBRLyjTYgoyRmWerKlAI2y7ZfgyXmQxTIkE17uDfMR0uYapKTZ2JDpz4GOUk-KSQTylbazJzXu6yTZTkIpVtS9jnVs2iDYVp-UclssUlvMfzfmDgop8s4OElvl3Oakbla-hkrqi0TFPqdg3UDReR3uBj-yCuxeMDp7cOFj_W40)
1. The thread running the method `verify_sad_nodes` is executed.
2. First it needs to extract the current `sad_entry_nodes` from the `init_sad_node` database.
3. With all the nodes. It enters a for which follows the following steps:
    3.1 It asks the kernel for the current information of the `sad_entry_node` using the `pf_getsad` method.
    *  `ipsec_mode`: tunnel/transport
    *  `spi`
    *  `req_id`: rule_number
    *  `tunnel_local and tunnel_remote`: IPs used to stablish the IPsec tunnel.
    *  `local_subnet and remote_subnet`: IP addresses or subnet that are going to be connected. 
    *  `encryption_key and integrity_key`: cryptographic material associated with the entries.
    3.2 This information is used to create a temporary `sad_entry_node` so it can so then it can be sent through the `verify_trusted_sad_entry` method to the TA using a `REQUEST_VERIFY_MSG` type message.
    3.3 As the other casses, this messages are handled by the method `handle_message`, which in this case will parse the information into a `sad_entry_node` so it can be directly compared in the `handle_request_verify_message` method with the one that must be previously installed in the `trusted_init_sad_node` database. 
    3.4 Once the values have been compared, if will report the result back to the RA using a `OP_RESULT_MSG` with a correct answer. Otherwirse it will return an `ALERT_STATE_MSG` reporting that the entries compared where not valid.
4. After detecting if an entry has been correctly validated or not the event should be registered (TODO).
